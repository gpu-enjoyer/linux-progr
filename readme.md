
# Linux Programming Course

[Visit the course page](https://courses.igankevich.com/linux-programming/)

```
Содержание:

01. Введение
02. Оболочка
03. Скрипты
04. Редакторы
05. Файловая система
06. Компиляторы
07. Репозитории кода
08. Системы сборки кода
09. Системные вызовы
10. Ввод/вывод
```


## 01. Введение

- [x] Базовые команды (1)

    Напишите команду, которая выведет все дочерние директории в директории /proc. Для этого прочитайте руководство команды find и найдите в нем нужные флаги. Команда для просмотра руководства: man find (то же самое можно набрать в поисковике). Проигнорируйте ошибки, связанные с правами доступа.  
    Напишите команду, которая выводит строчки файла в обратном порядке. Найдите в поисковике один из вариантов такой команды, который работает и понятен вам.  
    Напишите команду, которая выводит список файлов в текущей директории вместе с правами доступа, включая скрытые файлы. Директории должны идти в выводе перед файлами. Для этого в руководстве команды ls найдите все необходимые флаги.  

- [x] Файловая система sysfs (1)

    Напишите команду, которая выведет один из следующих параметров: температуру процессора, уровень заряда батареи ноутбука, яркость экрана монитора, — считав эти данные из соответствующего файла в sysfs. Воспользуетесь поисковиком, чтобы найти нужный файл.

- [x] Установка Linux (2)  

    Выберите дистрибутив Linux, который вам нравится больше всего, и установите его на свой ноутбук или настольный компьютер. 


## 02. Оболочка

- [x] Конвертация изображений (1)  

    Напишите скрипт, который преобразует все переданные в него в качестве аргументов файлы в формат PNG. Для этого скачайте файлы JPG или аналогичные из интернета (команда wget здесь может помочь) и в цикле вызовите команду convert для преобразования формата файлов. Это команла из пакета ImageMagick, документацию можно найти в интернете или man convert.

- [x] Мониторинг (1)  

    Напишите скрипт, который выводит показания всех датчиков температуры, которые поддерживаются ядром операционной системы. Для этого воспользуйтесь командой find, чтобы найти файлы в директории /sys, которые начинаются на "temp" и заканчиваются на "input". Затем в цикле пройдитесь по найденным файлам и выведите их содержимое командой cat.

- [ ] Параллельная обработка (1)

    Пожалуйста, не запускайте больше двух параллельных процессов на кластере!

    Перепишите скрипт из первого задания так, чтобы конвертировались несколько изображений параллельно.  
    Для этого воспользуйтесь запуском в фоновом режиме и командой wait, которая ждет завершения всех фоновых процессов.  
    Проверить, что команды работают параллельно, можно с помощью команды top, которая показывает загрузку ядер процессора в реальном времени.  
    Эту команду надо запустить в отдельном терминале.

- [ ] Конвейер (2)

    Напишите скрипт, который ищет файлы с изображениями формата JPG, конвертирует их в формат PNG. Поиск файлов и конвертация должны быть звеньями конвейера. Как вы думаете, для большого количества файлов (например, тысячи) этот скрипт будет работать быстрее скрипта из третьего задания или нет? 


## 03. Скрипты

- [x] Открытие файлов (1)  

    Напишите скрипт под названием open, который открывает файл в подходящей программе. Программа выбирается на основе MIME-типа файла. Этот тип определяется с помощью команды file, и вам нужно найти подходящий для этого флаг в документации. Затем для открытия файла используется программа, которая умеет работать с такими типами файлов: gimp, libreoffice, mpv. Тестовые файлы можно скачать здесь. Если вы делаете задание на сервере, то вместо запуска программы выведите нужную для запуска команду. Для выбора программы используйте условные переходы (case или if).

- [x] Аргументы (1)  

    Напишите скрипт, который принимает опции -x, -y и выводит погоду в точке с долготой X и широтой Y. Для определения погоды, используйте сайт wttr.in. Для обработки аргументов используйте встроенную функцию getopts (не перепутайте ее с getopt). Пример использования этой функции ниже.  

    ```bash
    # двоеточие после опции обозначает, что у нее есть значение, а не просто вкл./выкл.
    while getopts a:b: option
    do
        case "$option" in
            a echo "a=$OPTARG" ;;
            b) echo "b=$OPTARG" ;;
            *) echo "no options" ;;
        esac
    done
    ```

- [ ] Функции (1)

    Напишите функцию, которая запускает переданную в нее команду и перенаправляет стандартный поток вывода и поток ошибок в файл. Название файла передается в качестве первого аргумента, остальные аргументы — это команда. Пример вызова ниже.

    ```bash
    my_func /tmp/my-output ls -l
    ```

- [ ] Генерация файлов (2)

    Напишите скрипт, который генерирует еще один скрипт, который переименовывает все файлы в директории, меняя регистр на прописные буквы. Для генерации скрипта используйте генерацию потока ввода. Для изменения регистра используйте команду tr. Для переименования файлов используйте команду mv. Список файлов должен вставляться в скрипт с помощью подстановки во время генерации потока ввода. Пример результирующего скрипта показан ниже. Вам может пригодиться перенаправление потока вывода, которое не добавляет данные в конец файла, а не перезаписывает его. Оно реализуется с помощью символов >>.

    ```
    mv x X
    mv y Y
    mv z Z
    ```


## 04. Редакторы

- [x] Массовое переименование файлов (1)  

    Команда оболочки vidir из пакета moreutils используется для быстрого переименования файлов. Она запускает редактор, указанный в переменной среды EDITOR и в нем открывается специальный файл, в котором находятся имена файлов переданных команде. По умолчанию это имена файлов в текущей директории. Каждая строка пронумерована, поэтому, когда вы изменяете имена файлов и закрываете редактор, vidir повторяет все эти изменения в файловой системе. Предположим, что мы запустили env EDITOR=vim vidir. Напишите последовательность клавиш, которые надо нажать в редакторе vim, чтобы изменить регистр всех имен файлов в текущей директории на противоположный.


- [x] Массовая обработка строк (1)  

    У вас есть файл, где на каждой строчке есть некоторый набор символов, включая пробелы. Напишите макрос, который обернет одну строчку в кавычки. Макрос должен быть написан таким образом, что при повторении его N раз будут обернуты в кавычки N строк.

    ```bash
    hello world
    a line with leading white space
    1
    !@#$%^&*()
    ```

- [ ] Связь с оболочкой (1)

    Напишите последовательность клавиш, которые нужно нажать в редакторе vim, чтобы вставить текущую дату на следующую за курсором строчку.

- [ ] Преобразование XML в Java properties (2)

    Напишите макрос для преобразования следующего XML файла в файла формата Java Properties. В задании необходимо использовать текстовый объект типа "тег".

    ```xml
    <property>
    <name>dfs.namenode.name.dir</name>
    <value>/var/hdfs/name</value>
    </property>
    ```

    ```java
    dfs.namenode.name.dir=/var/hdfs/name
    ```


## 05. Файловая система

- [x] Стандартные права доступа (1)  

    Найдите все обычные файлы в текущей директории и всех дочерних директориях и измените их права доступа на стандартные для обычных файлов: чтение и запись для владельца-пользователя, чтение для владельца-группы и чтение для всех остальных. Для этого воспользуйтесь флагами -type и -exec команды find.
    Повторите то же самое для директорий. Стандартные права на директорию такие же, как на файл, но добавляется право поиска для всех.

- [x] Символьные ссылки (1)  

    Создайте пустую директорию dir. Напишите команду, которая создает символьную ссылку с именем my-dir на эту директорию. Повторный вызов команды должен обновлять ссылку. Найдите флаги команды ln, которые позволяют это сделать.

    ```bash
    # команды для проверки
    mkdir dir
    ln -s dir my-dir
    ln -s dir my-dir
    ln -s dir my-dir
    ```

- [ ] Точки монтирования (1)

    Выведите список точек монтирования из файла /proc/mounts. Выровняйте вывод по колонкам с помощью команды column. Для этого найдите подходящую опцию этой команды.

- [ ] Именованные каналы (2)

    Напишите скрипт, который читает построчно сообщения, отправленные в именованный канал и выводит их на экран вместе с текущей датой. Продемонстрируйте работу скрипта, запустив его в отдельном окне терминала, а в другом окне выведите в именованный канал какие-нибудь строчки. 


## 06. Компиляторы

- [x] Условная компиляция (1)  

    Напишите код для препроцессора, который в зависимости от значений макросов USE_GPU и USE_FLOAT, которые задаются с помощью флагов компилятора, выбирает одну из четырех версий кода, в зависимости от того, определен каждый из макросов или нет. Проверьте себя с помощью команды g++ -E.

- [ ] Тесты производительности (1)  

    Загрузите код sha1-benchmark, соберите его с минимальной и максимальной оптимизацией. Измерьте, насколько уменьшилось время работы программы с помощью команды time.

    ```bash
    git clone https://mirror.cmmshq.ru/linux-programming/sha1-benchmark.git # загрузка кода
    cd sha1-benchmark
    ... # компиляция
    time ./sha1-benchmark # измерение времени работы
    ```

- [ ] Оптимизация во время линковки (1)

    Повторите тесты производительности из предыдущего задания, но теперь используйте флаги оптимизации во время линковки.

- [ ] Оптимизация с помощью профилирования (2)

    Одна из редко используемых, но полезных, оптимизаций основана на профилировании: сначала программа собирается с опцией -fprofile-generate, затем запускаются тесты, генерирующие статистику, а затем программ пересобирается с опцией -fprofile-use, чтобы использовать собранную статистику для оптимизации программы. Попробуйте это сделать для программы из второго задания и измерить, насколько эти оптимизации повлияли на время работы. 


## 07. Репозитории кода

- [x] Первый репозиторий (1)  

    Создайте репозиторий, добавьте в него текстовый файл с содержимым "Hello world!" и зафиксируйте изменения. Проверьте себя с помощью команды git log.

- [x] Ветки (1)  

    Создайте в репозитории из первого задания новую ветку и добавьте в него новый файл с произвольным содержимым. Зафиксируйте изменения и слейте новую ветку с основной. Проверьте себя с помощью команды git log.

- [ ] Синхронизация (1)

    В отдельной директории вне текущего репозитория создайте новый репозиторий с помощью команды git init --bare. Он будет выполнять роль репозитория на сервере, хоть и находится на той же машине. Отправьте в этот репозиторий изменения из предыдущего задания с помощью команды git push. Затем склонируйте этот репозиторий в еще одну директорию и проверьте с помощью команды git log, что вся история изменений сохранилась.

- [ ] Исправление конфликтов (2)

    В репозитории из второго задания создайте новую ветку, измените в ней один из файлов, зафиксируйте изменения и отправьте на сервер. Затем в склонированном репозитории из третьего задания создайте новую ветку с другим именем, измените в ней тот же файл, зафиксируйте изменения и отправьте на сервер. Теперь слейте обе ветки в основную с помощью git merge и исправьте конфликтующие изменения вручную. 


## 08. Системы сборки кода

- [x] Make (1)  

    Напишите Makefile с правилами для сборки программы, состоящей из файлов main.cc и main.hh: первый файл включает второй с помощью #include. Программа должна пересобираться при изменении main.hh. Команды сборки писать не надо, просто укажите зависимости между файлами.

- [ ] Make + pkg-config (1)  

    Соберите код из первого задания с библиотекой zlib. Библиотеку подключите с помощью pkg-config.

- [ ] Meson (1)

    Соберите код из первого задания с библиотекой zlib с помощью Meson.

- [ ] Git + Meson (2)

    Скачайте проект unistdx с помощью команды git. Соберите его с помощью Meson с флагами компилятора -march=native -O3 и флагом линковщика -flto. 


## 09. Системные вызовы

- [ ] Системные вызовы (1)  

    Сделайте системный вызов getpid с помощью одноименной функции-обертки из заголовочного файла unistd.h. Сделайте тот же самый вызов с помощью универсальной функции-обертки syscall. Удостоверьтесь, что они возвращают одинаковые значения.

- [ ] Дочерние процессы (1)  

    Создайте дочерний процесс с помощью функции-обертки fork и запустите в нем команду expr 2 + 2 * 2 с помощью системного вызова execlp. Дождитесь завершения дочернего процесса с помощью функции wait.

- [ ] Переменные среды (1)

    Выведите переменные среды, имя которых содержит символ "L". Для этого воспользуйтесь глобальной переменной environ из заголовочного файла environ.h.

- [ ] Аргументы и пространства имен (2)

    Создайте дочерний процесс, в котором вы измените имя компьютера на имя, переданное родительскому процессу в качестве первого аргумента. Для этого воспользуйтесь системным вызовом clone и подходящими флагами этого вызова, а также системным вызовом sethostname. Проверьте с помощью вызова gethostname, что имя компьютера разное в дочернем и родительском процессе. 


## 10. Ввод/вывод

- [ ] Ввод/вывод (1)  

    Напишите класс-обертку File, который в конструкторе открывает файл, а в деструкторе закрывает. Добавьте методы для записи в файл, чтения из файла. Проверьте выходное значение каждого системного вызова с помощью функции check.

- [ ] Перемещение (1)  

    Добавьте в класс File конструкторы и операторы перемещения. Проверьте, что файловые дескрипторы корректно закрываются с помощью команды valgrind --track-fds=yes ./a.out.

- [ ] Позиция в файле (1)

    Добавьте в класс File метод для получения и изменения текущей позиции в файле относительно его начала. Для этого воспользуйтесь системным вызовом lseek.

- [ ] Копирование файловых дескрипторов (2)

    Добавьте в класс File конструкторы и операторы копирования и перемещения. Файловый дескриптор можно скопировать функцией dup и dup2 (в конструкторе и операторе копирования используются разные функции!). Файловый дескриптор со значением -1 можно считать нейтральным (как nullptr для указателя). Проверьте, что файловые дескрипторы корректно закрываются с помощью команды valgrind --track-fds=yes ./a.out.
