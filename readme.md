
# Linux Programming Course

[Visit the course page](https://courses.igankevich.com/linux-programming/)

```
Содержание:

01. Введение
02. Оболочка
03. Скрипты
04. Редакторы
05. Файловая система
06. Компиляторы
07. Репозитории кода
08. Системы сборки кода
09. Системные вызовы
10. Ввод/вывод
```

## 01. Введение

- [x] Установка Linux (2)  

    Выберите дистрибутив Linux, который вам нравится больше всего, и установите его на свой ноутбук или настольный компьютер. 

## 02. Оболочка

- [x] Конвертация изображений (1)  

    Напишите скрипт, который преобразует все переданные в него в качестве аргументов файлы в формат PNG. Для этого скачайте файлы JPG или аналогичные из интернета (команда wget здесь может помочь) и в цикле вызовите команду convert для преобразования формата файлов. Это команла из пакета ImageMagick, документацию можно найти в интернете или man convert.

- [x] Мониторинг (1)  

    Напишите скрипт, который выводит показания всех датчиков температуры, которые поддерживаются ядром операционной системы. Для этого воспользуйтесь командой find, чтобы найти файлы в директории /sys, которые начинаются на "temp" и заканчиваются на "input". Затем в цикле пройдитесь по найденным файлам и выведите их содержимое командой cat. 

## 03. Скрипты

- [ ] Открытие файлов (1)  

    Напишите скрипт под названием open, который открывает файл в подходящей программе. Программа выбирается на основе MIME-типа файла. Этот тип определяется с помощью команды file, и вам нужно найти подходящий для этого флаг в документации. Затем для открытия файла используется программа, которая умеет работать с такими типами файлов: gimp, libreoffice, mpv. Тестовые файлы можно скачать здесь. Если вы делаете задание на сервере, то вместо запуска программы выведите нужную для запуска команду. Для выбора программы используйте условные переходы (case или if).

- [ ] Аргументы (1)  

    Напишите скрипт, который принимает опции -x, -y и выводит погоду в точке с долготой X и широтой Y. Для определения погоды, используйте сайт wttr.in. Для обработки аргументов используйте встроенную функцию getopts (не перепутайте ее с getopt). Пример использования этой функции ниже.  

```shell
# двоеточие после опции обозначает, что у нее есть значение, а не просто вкл./выкл.
while getopts a:b: option
do
    case "$option" in
        a echo "a=$OPTARG" ;;
        b) echo "b=$OPTARG" ;;
        *) echo "no options" ;;
    esac
done
```

## 04. Редакторы

- [ ] Массовое переименование файлов (1)  

    Команда оболочки vidir из пакета moreutils используется для быстрого переименования файлов. Она запускает редактор, указанный в переменной среды EDITOR и в нем открывается специальный файл, в котором находятся имена файлов переданных команде. По умолчанию это имена файлов в текущей директории. Каждая строка пронумерована, поэтому, когда вы изменяете имена файлов и закрываете редактор, vidir повторяет все эти изменения в файловой системе. Предположим, что мы запустили env EDITOR=vim vidir. Напишите последовательность клавиш, которые надо нажать в редакторе vim, чтобы изменить регистр всех имен файлов в текущей директории на противоположный.


- [ ] Массовая обработка строк (1)  

    У вас есть файл, где на каждой строчке есть некоторый набор символов, включая пробелы. Напишите макрос, который обернет одну строчку в кавычки. Макрос должен быть написан таким образом, что при повторении его N раз будут обернуты в кавычки N строк.

```shell
hello world
 a line with leading white space
1
!@#$%^&*()
```

## 05. Файловая система

- [ ] Стандартные права доступа (1)  

    Найдите все обычные файлы в текущей директории и всех дочерних директориях и измените их права доступа на стандартные для обычных файлов: чтение и запись для владельца-пользователя, чтение для владельца-группы и чтение для всех остальных. Для этого воспользуйтесь флагами -type и -exec команды find.
    Повторите то же самое для директорий. Стандартные права на директорию такие же, как на файл, но добавляется право поиска для всех.

- [ ] Символьные ссылки (1)  

    Создайте пустую директорию dir. Напишите команду, которая создает символьную ссылку с именем my-dir на эту директорию. Повторный вызов команды должен обновлять ссылку. Найдите флаги команды ln, которые позволяют это сделать.

```shell
# команды для проверки
mkdir dir
ln -s dir my-dir
ln -s dir my-dir
ln -s dir my-dir
```

## 06. Компиляторы

- [ ] Условная компиляция (1)  

    Напишите код для препроцессора, который в зависимости от значений макросов USE_GPU и USE_FLOAT, которые задаются с помощью флагов компилятора, выбирает одну из четырех версий кода, в зависимости от того, определен каждый из макросов или нет. Проверьте себя с помощью команды g++ -E.

- [ ] Тесты производительности (1)  

    Загрузите код sha1-benchmark, соберите его с минимальной и максимальной оптимизацией. Измерьте, насколько уменьшилось время работы программы с помощью команды time.

```shell
git clone https://mirror.cmmshq.ru/linux-programming/sha1-benchmark.git # загрузка кода
cd sha1-benchmark
... # компиляция
time ./sha1-benchmark # измерение времени работы
```

## 07. Репозитории кода

- [x] Первый репозиторий (1)  

    Создайте репозиторий, добавьте в него текстовый файл с содержимым "Hello world!" и зафиксируйте изменения. Проверьте себя с помощью команды git log.

- [x] Ветки (1)  

    Создайте в репозитории из первого задания новую ветку и добавьте в него новый файл с произвольным содержимым. Зафиксируйте изменения и слейте новую ветку с основной. Проверьте себя с помощью команды git log.

## 08. Системы сборки кода

- [x] Make (1)  

    Напишите Makefile с правилами для сборки программы, состоящей из файлов main.cc и main.hh: первый файл включает второй с помощью #include. Программа должна пересобираться при изменении main.hh. Команды сборки писать не надо, просто укажите зависимости между файлами.

- [ ] Make + pkg-config (1)  

    Соберите код из первого задания с библиотекой zlib. Библиотеку подключите с помощью pkg-config. 

## 09. Системные вызовы

- [ ] Системные вызовы (1)  

    Сделайте системный вызов getpid с помощью одноименной функции-обертки из заголовочного файла unistd.h. Сделайте тот же самый вызов с помощью универсальной функции-обертки syscall. Удостоверьтесь, что они возвращают одинаковые значения.

- [ ] Дочерние процессы (1)  

    Создайте дочерний процесс с помощью функции-обертки fork и запустите в нем команду expr 2 + 2 * 2 с помощью системного вызова execlp. Дождитесь завершения дочернего процесса с помощью функции wait.

## 10. Ввод/вывод

- [ ] Ввод/вывод (1)  

    Напишите класс-обертку File, который в конструкторе открывает файл, а в деструкторе закрывает. Добавьте методы для записи в файл, чтения из файла. Проверьте выходное значение каждого системного вызова с помощью функции check.

- [ ] Перемещение (1)  

    Добавьте в класс File конструкторы и операторы перемещения. Проверьте, что файловые дескрипторы корректно закрываются с помощью команды valgrind --track-fds=yes ./a.out.
